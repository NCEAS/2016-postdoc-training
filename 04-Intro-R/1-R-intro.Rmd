---
title: "Short Introduction to R"
author: "Adapted by Julien Brun from OSS 2014"
date: "June, 2016"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
---

# Starting with R

R consoole
1. Connect to Aurora via ssh
2. Start R in interactive mode from the terminal

Or use RStudio IDE

1. https://aurora.nceas.ucsb.edu/rstudio/
2. login


# R data types
There are 5 main types: double, integer, complex, logical and character.


## Numbers (double and integer shown)

```{r, eval = FALSE}
2 * 3
x <- 3 ^ 2
x
y <- 5
y
z <- x / y
z  # Python would have returned an integer!!
```

x, y and z in the above example are called varialbes. In R you assign into the environement values to variables  using ```<-```. You can also use ```=```

![tips](images/tip.png) Did you know you that in RStudio you can use ``alt```+ ```-``` to write ```<-``` in one keystroke?

## Characters
```{r, eval = FALSE}
# You tell R that you are inputting a character by using quotes (single or double) around the text you would like to enter

"That's easy"
'This work to'

# What happen if you forget the quotes?
"a"
a

# In this case?
"x"
x

# Why?

# Combining characters
my_first_name <- "Julien"
my_last_name <- "Brun"

my_full_name <- my_first_name + my_first_name # Would have worked in Python!

# In R you can use the functino paste()
# how do I know how paste work?

?paste

# use spacebar to scroll by page and q to quit the help

paste(my_first_name, my_last_name, sep=" ")

```


# Input output operations

## Inputting data

```{r, eval = FALSE}
x <- scan("data_file.txt")
# add a separator
x <- scan("data/messy_data.txt", what=" ", sep = "\n")
# or read data from the console
x <- scan()
# keep entering values and hit an empty return key to end
```
Reading single lines (e.g. user input)

```{r, eval = FALSE}
variable <- readline()
# or provide more information
variable <- readline("Enter number of simulations: ")
```


## Reading files  
Most plain text files can be read with `read.table` or variants thereof (such as `read.csv`).

```{r, eval = FALSE}
df <- read.table("data.dat", header = TRUE)
```

or using `readLines`

```{r, eval = FALSE}
dt <- readLines("data/messy_data.txt")
head(dt)
```

## Files from the web

```{r, eval = FALSE}
url <- "data/climate.csv"
my_data <- read.csv(url, header = TRUE)
head(my_data)
```

## Local file operations

One can list files from any local source as well.

```{r, eval = FALSE}
list.files()
file.info()
dir()
file.exists()
getwd()
setwd()
```


---



## Writing files

Saving files is easy in R. Load the `iris` dataset by running `data(iris)`. Can you save this back to a `csv` file to disk with the name `tgac_iris.csv`?

What commands did you use?


# Short term storage

```{r, eval = TRUE}
saveRDS(iris, file = "my_iris.rds")
iris_data <- readRDS("my_iris.rds")
unlink("my_iris.rds")
```
This is great for short term storage. All factors and other modfications to the dataset will be preserved. However, only R can read these data back and not the best option if you want to keep the file stored in the easiest format.

# Long-term storage

```{r, eval = FALSE}
write.csv(iris, file = "my_iris.csv", row.names = FALSE)
```

# Easy to store compressed files to save space:

```{r, eval = FALSE}
write.csv(diamonds, file = bzfile("diamonds.csv.bz2"),
  row.names = FALSE)
```

# Reading is even easier:

```{r, eval = FALSE}
diamonds5 <- read.csv("diamonds.csv.bz2")
```

Files stored with `saveRDS()` are automatically compressed.


# R data structures

|  Dimension   | Homogeneous    | Heterogeneous |
| ------------ | -------------  | ------------- |
| 1d           | Atomic vector  | List          |
| 2d           | Matrix         | Data frame    |
| nd           | Array          |               |

	
```str()``` is short for *structure* and it gives a compact, human readable description of any R data structure.

## Vector

Vectors have three common properties:

 * Type, `typeof()`, what it is.
 * Length, `length()`, how many elements it contains.
 * Attributes, `attributes()`, additional arbitrary metadata.


### a. Atomic vector

You construct an atomic vector using ```c() ```.

All elements of an atomic vector must be the same type, so when you attempt to combine different types they will be **coerced** to the most flexible type. Types from least to most flexible are: logical, integer, double, and character.


### b. List

You construct an atomic vector using ```list() ```.

The elements of a list can be of different types. List can be nested (list of lists). 

You can turn a list into an atomic vector with `unlist()`. If the elements of a list have different types, `unlist()` uses the same coercion rules as `c()`.

## Matrix and array

Matrices and arrays are created with `matrix()` and `array()`, or by using the assignment form of `dim()`.

High-dimensional generalisations:

* *length()* generalises to *nrow()* and *ncol()* for matrices, and *dim()* for arrays.

* *names()* generalises to *rownames()* and *colnames()* for matrices, and *dimnames(*), a list of character vectors, for arrays.

* *c()* generalises to *cbind()* and *rbind()* for matrices, and to *abind()* (provided by the abind package) for arrays. 

## Data frame

You construct an atomic vector using ```data.frame() ```. Note that *data.frame()*â€™s default behaviour which turns strings into factors. Use ```stringAsFactors = FALSE``` to suppress this behaviour

```{r, eval = FALSE}
d <- data.frame(a = c(1,2,3,4,5), 
                b = c(6,7,8,9,8))

```

A data frame is the **most common way of storing data** in R. A data frame is in fact a list of equal-length vectors, meaning the columns can be of different types, but the row are of the same type in each column.


