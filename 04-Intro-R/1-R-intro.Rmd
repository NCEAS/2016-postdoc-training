---
title: "Short Introduction to R"
author: "Julien Brun"
date: "June, 2016"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
---

*Attribution*: this tutorial sources are material prepared by NCEAS for the [summer school 2013](), [Advanced R](http://adv-r.had.co.nz/) by H. Wickham, [STAT 545](http://stat545.com/index.html) @ University of British Columbia,  and [R tutorial](http://www.r-tutor.com/r-introduction) by Chi Yau


# Starting R

## R console
1. Connect to Aurora via ssh
2. Start R in interactive mode from the terminal

## RStudio IDE

RStudio is an Integrated Development Environment (IDE). It enables you to work and developp your script comfortably, but it is not required. R is running under the hood. Also note that we are using _RStudio server_ when connecting to Aurora via our web browser, but the the equivalent [desktop](https://www.rstudio.com/products/rstudio/) aplication also exists.

1. https://aurora.nceas.ucsb.edu/rstudio/
2. login


*Important Note*: NCEAS is running the communityt version of RStudio server that support only one login at the time. If you are logged in and you login from another machine, webrowser, it will kill your session and stop any exectution of a script currently running. For long processing, we therefore recommend to use the command line  with `Rscript`.


# R data types and basic manipulations

There are 5 main types: double, integer, complex, logical and character.

## Which one of these R commands you do not know?

```{r vocabulary math, eval = FALSE}

# Comparison 
all.equal, identical
!=, ==, >, >=, <, <=
is.na, complete.cases
is.finite

# Basic math
*, +, -, /, ^, %%, %/%
abs, sign
acos, asin, atan, atan2
sin, cos, tan
ceiling, floor, round, trunc, signif
exp, log, log10, log2, sqrt

max, min, prod, sum
cummax, cummin, cumprod, cumsum, diff
range
mean, median, cor, sd, var

# Logical & sets 
&, |, !, xor
all, any
intersect, union, setdiff, setequal
which
```


## Numeric (double and integer shown here)

```{r, eval = FALSE}
2 * 3
x <- 3 ^ 2
x

y <- 5
y
z <- x / y
z                # Python would have returned an integer!!
x %/% y          # like this
x %% y           # modulo
```

x, y and z in the above example are called varialbes. In R you *assign* to the local environement values to variables  using `<-`. Note `=` also exists, but behave slightly differently. We recommend to use `<-`. See [here](http://stackoverflow.com/questions/1741820/assignment-operators-in-r-and) if you want to know more about the differences.

![tips](images/tip.png) Did you know you that in RStudio you can use `alt`+ `-` to write `<-`?

## Characters
```{r, eval = FALSE}
# You tell R that you are inputting a character by using quotes (single or double) around the text you would like to enter

"That's easy"
'This work to'

# What happen if you forget the quotes?
a

# In this case?
x

# Why?

# Combining characters
my_first_name <- "Julien"
my_last_name <- "Brun"

my_full_name <- my_first_name + my_first_name # Would have worked in Python!

# In R you can use the functino paste()
# how do I know how paste work?

?paste

# use spacebar to scroll by page and q to quit the help

paste(my_first_name, my_last_name, sep=" ")

```


## logical 

Adapted from from [_R Tutorial_](http://www.r-tutor.com/r-introduction/basic-data-types/logical)

A logical value is often created via comparison between variables.
```{r logical, eval=FALSE}
x <- 1; y <- 2   # sample values 
x > y      # is x larger than y? 

z <- x > y
class(z)       # print the class name of z


u <- TRUE; v <- FALSE 
u & v          # u AND v 
u | v          # u OR v 
!u             # negation of u 

# with vectors
vu <- c(TRUE, FALSE, TRUE)
vv <- c(TRUE, FALSE, FALSE)

vu & vv
vu && vv #(takes only the first element in comparison)
```


# R data structures

|  Dimension   | Homogeneous    | Heterogeneous |
| ------------ | -------------  | ------------- |
| 1d           | Atomic vector  | List          |
| 2d           | Matrix         | Data frame    |
| nd           | Array          |               |

	
`str()` is short for *structure* and it gives a compact, human readable description of any R data structure.

## Vector

Vectors have three common properties:

 * Type, `typeof()`, what it is.
 * Length, `length()`, how many elements it contains.
 * Attributes, `attributes()`, additional arbitrary metadata.

### a. Atomic vector

You construct an atomic vector using `c() `.
```{r atomic vector, eval= FALSE}
# numeric vector
a <- c(1,2,3)
# character vector
b <- c("a", "b", "c")
```

All *elements of an atomic vector must be the same type*, so when you attempt to combine different types they will be **coerced** to the most flexible type. Types from least to most flexible are: logical, integer, double, and character

```{r coersion, eval= FALSE}
#combine the two, what do you get?
ab <- c(a,b)
typeof(ab)
```

### b. List

You construct an atomic vector using ```list() ```.

The elements of a list can be of different types. List can be nested (list of lists). 

You can turn a list into an atomic vector with `unlist()`. If the elements of a list have different types, `unlist()` uses the same coercion rules as `c()`.

## Matrix and array

Matrices and arrays are created with `matrix()` and `array()`, or by using the assignment form of `dim()`.

High-dimensional generalisations:

- *length()* generalises to *nrow()* and *ncol()* for matrices, and *dim()* for arrays.

- *names()* generalises to *rownames()* and *colnames()* for matrices, and *dimnames(*), a list of character vectors, for arrays.

- *c()* generalises to *cbind()* and *rbind()* for matrices, and to *abind()* (provided by the abind package) for arrays. 

## Data frame

You construct an atomic vector using ```data.frame() ```. Note that *data.frame()*â€™s default behaviour which turns strings into factors. Use ```stringAsFactors = FALSE``` to suppress this behaviour

```{r, eval = FALSE}
d <- data.frame(a = c(1,2,3,4,5), 
                b = c(6,7,8,9,8))
```

A data frame is the **most common way of storing data** in R. A data frame is in fact a list of equal-length vectors, meaning the columns can be of different types, but the row are of the same type in each column.

# Working directory

When you are working with input/output files and more generally with script, it is very important that you set your working directory `setwd()`. The best parallel is to see your working directory as the top level directory containing files and subfolder. It will allow you to set paths realtively to your working directory and keep your code running even if you move your top-level directory to another location on your drive or to another machine.

![warning](images/warning.png) Note we recommend to use set the directory clearly at the beginning of your script and to not change your working directory within your script as it makes it harder to reproduce.

## Getting and setting the current directory

```{r setting working dir, eval = FALSE}
# What is the current directory
getwd()

# Setting the current directory
setwd("~/snapp-workshop/introR")
```

## Note on how to build a path in R:

To construct a path to a file, it is recommended to use `file.path` and not `paste` as it will take care of the dfifferent path convention bewteen OS and it id faster.


# Input / output operations

## Inputting data

```{r, eval = FALSE}
x <- scan("data_file.txt")
# add a separator
x <- scan("data/messy_data.txt", what=" ", sep = "\n")
# or read data from the console
x <- scan()
# keep entering values and hit an empty return key to end
```

## Reading single lines (e.g. user input)

```{r, eval = FALSE}
variable <- readline()
# or provide more information
variable <- readline("Enter number of simulations: ")
```


## Reading files  
Most plain text files can be read with `read.table` or variants thereof (such as `read.csv`).

```{r, eval = FALSE}
df <- read.table("data.dat", header = TRUE)
```

or using `readLines`

```{r, eval = FALSE}
dt <- readLines("data/messy_data.txt")
head(dt)
```

## Files from the web

```{r, eval = FALSE}
url <- "data/climate.csv"
my_data <- read.csv(url, header = TRUE)
head(my_data)
```

## Local file operations

One can list files from any local source as well.

```{r, eval = FALSE}
list.files()
file.info()
dir()
file.exists()
getwd()
setwd()
```



## Writing files

Saving files is easy in R. Load the `iris` dataset by running `data(iris)`. Can you save this back to a `csv` file to disk with the name `tgac_iris.csv`?

What commands did you use?


# Short term storage

```{r, eval = TRUE}
saveRDS(iris, file = "my_iris.rds")
iris_data <- readRDS("my_iris.rds")
unlink("my_iris.rds")
```
This is great for short term storage. All factors and other modfications to the dataset will be preserved. However, only R can read these data back and not the best option if you want to keep the file stored in the easiest format.

# Long-term storage

```{r, eval = FALSE}
write.csv(iris, file = "my_iris.csv", row.names = FALSE)
```

# Easy to store compressed files to save space:

```{r, eval = FALSE}
write.csv(diamonds, file = bzfile("diamonds.csv.bz2"),
  row.names = FALSE)
```

# Reading is even easier:

```{r, eval = FALSE}
diamonds5 <- read.csv("diamonds.csv.bz2")
```

Files stored with `saveRDS()` are automatically compressed.


# References

- RStudio shortcuts: https://support.rstudio.com/hc/en-us/articles/200711853-Keyboard-Shortcuts
- Cleaning data with R: https://cran.r-project.org/doc/contrib/de_Jonge+van_der_Loo-Introduction_to_data_cleaning_with_R.pdf
- R for reproducible science: http://swcarpentry.github.io/r-novice-gapminder/04-data-structures-part1.html
